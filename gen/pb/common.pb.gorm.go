package pb

import (
	"context"
	"time"

	ptypesImport "github.com/golang/protobuf/ptypes"
	stdTimeImport "time"
)

type PostORM struct {
	ID        string              `gorm:"type:uuid;primaryKey"`
	CreatedAt *stdTimeImport.Time `gorm:"default:CURRENT_TIMESTAMP;not null"`
	UpdatedAt *stdTimeImport.Time `gorm:"default:CURRENT_TIMESTAMP;not null"`
	Header    string              `gorm:"not null;uniqueIndex:idx_post_header"`
	Body      string              `gorm:"type:text;not null"`
	Tags      []*PostTagORM       `gorm:"foreignKey:PostID;references:ID"`
}

// TableName overrides the default tablename generated by GORM
func (PostORM) TableName() string {
	return "posts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Post) ToORM(ctx context.Context) (PostORM, error) {
	to := PostORM{}
	var err error
	if prehook, ok := interface{}(m).(PostWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ID = m.ID
	if m.GetCreatedAt() != nil {
		var t time.Time
		if t, err = ptypesImport.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.GetUpdatedAt() != nil {
		var t time.Time
		if t, err = ptypesImport.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Header = m.Header
	to.Body = m.Body
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(PostWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PostORM) ToPB(ctx context.Context) (Post, error) {
	to := Post{}
	var err error
	if prehook, ok := interface{}(m).(PostWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ID = m.ID
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypesImport.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypesImport.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Header = m.Header
	to.Body = m.Body
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(PostWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Post the arg will be the target, the caller the one being converted from

// PostWithBeforeToORM called before default ToORM code
type PostWithBeforeToORM interface {
	BeforeToORM(context.Context, *PostORM) error
}

// PostWithAfterToORM called after default ToORM code
type PostWithAfterToORM interface {
	AfterToORM(context.Context, *PostORM) error
}

// PostWithBeforeToPB called before default ToPB code
type PostWithBeforeToPB interface {
	BeforeToPB(context.Context, *Post) error
}

// PostWithAfterToPB called after default ToPB code
type PostWithAfterToPB interface {
	AfterToPB(context.Context, *Post) error
}

type PostTagORM struct {
	Tag    string `gorm:"not null;uniqueIndex:idx_tag_name"`
	PostID string `gorm:"not null;uniqueIndex:idx_tag_name"`
}

// TableName overrides the default tablename generated by GORM
func (PostTagORM) TableName() string {
	return "post_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PostTag) ToORM(ctx context.Context) (PostTagORM, error) {
	to := PostTagORM{}
	var err error
	if prehook, ok := interface{}(m).(PostTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Tag = m.Tag
	if posthook, ok := interface{}(m).(PostTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PostTagORM) ToPB(ctx context.Context) (PostTag, error) {
	to := PostTag{}
	var err error
	if prehook, ok := interface{}(m).(PostTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Tag = m.Tag
	if posthook, ok := interface{}(m).(PostTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PostTag the arg will be the target, the caller the one being converted from

// PostTagWithBeforeToORM called before default ToORM code
type PostTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *PostTagORM) error
}

// PostTagWithAfterToORM called after default ToORM code
type PostTagWithAfterToORM interface {
	AfterToORM(context.Context, *PostTagORM) error
}

// PostTagWithBeforeToPB called before default ToPB code
type PostTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *PostTag) error
}

// PostTagWithAfterToPB called after default ToPB code
type PostTagWithAfterToPB interface {
	AfterToPB(context.Context, *PostTag) error
}
